相关链接：https://www.jianshu.com/p/fc95603b8cf0

#### 1、为什么利用多个域名来存储网站资源会更有效

1. CDN 缓存更方便
2. 突破浏览器并发限制
3. 节约 `cookie` 带宽
4. 节约主域名的连接数，优化页面响应速度
5. 防止不必要的安全问题

#### 2、从输入URL到页面加载全过程

1. 全过程详情

2. 缓存策略

3. http和https 的区别

   >1、https 多了一个ssl层；
   >
   >2、ssl 可以对传输的数据进加密和用户身份认证，所以比较安全
   >
   >3、端口不同：http 是80 ,https 是443
   >
   >4、和服务器建立连接连接方式不同，https 比较复杂；
   >
   >5、https 需要证书,http 不需要

4. dns 解析

5. 同源策略

6. 处理跨域方案

7. TCP/IP连接和三次握手

8. 浏览器 dom 渲染机制

   ##### 2.1 加载过程简介

   - 用户输入url
   - 根据用户的url,判断获取是否直接取缓存数据(强缓存)，还是重新获取数据(协商缓存)
   - dns 解析url为对应的ip地址
   - 客户端根据ip,通过tcp/ip的三次握手，和服务器建立连接
   - 客户端发起http 请求
   - 服务器接收到请求，返回数据
   - 浏览器根据返回数据，渲染页面
   - tcp四次挥手，断开连接

   ##### 2.2 强制缓存和协商缓存

   参考资料：https://juejin.im/entry/5ad86c16f265da505a77dca4

   ###### 强缓存：没有缓存，向服务器请求数据，有缓存，判断缓存是否过期，没过期，使用缓存。过期，进入到协商缓存阶段；

   ###### 协商缓存：将资源一些相关信息返回服务器，让服务器判断浏览器是否能直接使用本地缓存或者从服务器返回新的数据，写入缓存；

   强缓存相关字段： expires(很少使用，存在服务器时间和浏览器时间不一致的情况)**、**cache-control中的max-age字段(优先级高于 expires）

   协商缓存相关字段：Last-Modified/If-Modified-Since(客户端再次请求时带上)、Etag/If-None-Match(客户端再次请求时带上)，Etag/If-None-Match优先级比Last-Modified/If-Modified-Since 高

   ##### 2.3 Http 和Https请求

   Http 请求包括起始行，请求头和请求体三部分

   ###### 起始行

   >http 协议版本、请求方式、url地址

   

   ##### 2.4 dns 解析

   dns 解析：将 url 地址通过一定映射规则，找到对应的ip地址

   ###### 方式

   > 1、先在本地hosts 文件中，找到映射的ip地址，找到就返回，没有找到就继续第二步；
>
   > 2、在本地的dns 解析器缓存中查找，找到就返回，找不到继续第3步骤；
   >
   > 3、在本地的dns 服务器其中查找，找到就返回，没有找到，继续下面的迭代查找；
>
   > 4、按根域服务器 ->顶级域,.cn->第二层域，[hb.cn](https://link.jianshu.com/?t=http://hb.cn) ->子域，[www.hb.cn](https://link.jianshu.com/?t=http://www.hb.cn)的顺序找到IP地址.

   PS：在第4个步骤中，先查询域，通过第四个步骤中的顺序，直到找到对应的域和对应的ip，然后从最底层，逐级向上找，返回对应的IP

####3、回流和重绘

###### 回流/重排

> 当dom发生位置、大小、内容和解构等的变化，就会触发dom重新渲染，成为回流，回流的代价很大，尽量不要触发回流，会影响到页面布局

###### 重绘

>当影响dom的外观，发生改变时，就会触发重绘，比如说，颜色、字体大小等。重绘的代价比回流的代价小，不会影响到布局

**回流一定会引起重绘，重绘不一定引起回流**



#### 4、为何将资源放在多个域名之下效率会更高？

1. 节约***cookie***带宽：比如说，在访问一张图片的时候，在主站上，但是访问图片是不需要cookie的，这个时候，cookie站的带宽就浪费了。就可以将图片放在专门存储图片的域名之下，就可以节约cookie 的带宽了。
2. 使用***cnd缓存***，可以更快的获取到缓存数据，节省用户时间，cdn 网络开始布置的时候就近原则。
3. 节约***主域名***连接数，访问主要网页时，首先会访问主域名下各种资源，由于同一域名下有***访问连接数***的限制，因此将资源放在不同的域名之下，可以节约访问主域名访问连接数；
4. 突破***浏览器并发连接***限制，由于浏览器有***访问连接数***的限制，因此将资源放在不同的域名之下，可以突破访问连接数的限制；
5. 避免不必要的安全问题：上传奇怪的js ,窃取主站的cookie

#### 5、同源策略

```
 受同源策略的限制，只有同源网站的 Cookie才能共享。

   1.cookie：对域名要求相同；
    cookie只有同源的网站才能获取，但是如果两个网页的一级域名相同，只有二级域名不同，可以设置相同的document.domain(因为document.domain 只是对子域名能设置跨域访问)，两个网页就可以共享cookie了

    域名的等级划分：

顶级域名：.com
一级域名：baidu.com
二级域名：tieba.baidu.com
  例如，a网页是http://abc.com/a.html，b网页是http://abc.com/b.html，我们可以设置document,.domain = 'abc.com',a与b可以共享cookie
```

#### 6、跨域

跨域原因：由于同源策略的影响，不能访问不同源的资源，需要访问就会产生跨域

跨域方式：CORS、JSONP、WebSocket

###### JSONP:只能是 get 请求

>本质是因为能够访问不同域名下的js文件。
>
>生成一个script 标签，将需要访问的请求作为src的属性值，同时在请求中添加callback作为请求参数，在脚本中执行回调函数，请求成功之后的数据在回调函数中获取；

***主要参数***

>参数
>
>dataType:'jsonp', // 返回的数据类型
>
>JsonpCallback:'cb' // 指定回调函数类型
>
>Jsonp:'newCallback' // 指定回调函数属性的名称，将callback改为newCallback

1、默认回调函数success

![image-20200227133743483](/Users/franklin/Library/Application Support/typora-user-images/image-20200227133743483.png)

2、指定回调函数

![image-20200227133628485](/Users/franklin/Library/Application Support/typora-user-images/image-20200227133628485.png)

###### CORS：需要在服务端进行配置

本质是使用自定义的HTTP头部允许浏览器和服务器相互访问对方

***主要参数***

> Access-Control-Allow-Origin // 指定能够授权访问的域，* 表示所有的域
>
> Access-Control-Allow-Methods // 授权使用的方法，不限于get，包括post、delete、put等

![image-20200227141022429](/Users/franklin/Library/Application Support/typora-user-images/image-20200227141022429.png)

###### WebSocket

#### 7、Session、Cookie和各种缓存

Session 和 Cookie 存储的是状态信息；

浏览器缓存 存储在memory cache 和disk cache 中，进程关闭，该进程中缓存在memory cache 中的资源将消失

memeory cache 缓存时效性高、速度快，通常存储静态图片，js、css 资源，浏览器在渲染过程中抓取的的资源；disk cache 通常缓存复杂，体积比较大的内容，css 文件，js文件,memory 不够的时候，吧数据放到disk cache 中



但是 memory cache 和disk cache 存储哪些东西需要看配置

> memory cache:只能缓存派生资源，



***协商缓存和强制缓存 参照 2.2 节***

#### 8、浏览器渲染机制

参考资料：https://juejin.im/entry/59e1d31f51882578c3411c77

######渲染过程

>1. 原则上将<script>加载的js和<link>加载的css 资源视为阻塞资源；
>2. 浏览器加载资源按照顺序进行，首先遇到dom ,并解析构建dom树；
>3. 当只有css 和html 的情况：遇到link标签，异步请求css 资源，并不会影响dom 的解析和构建，加载完之后，继续解析构建dom ；
>4. 当其中有js 资源的时候，页面阻塞，所有的构建和解析停止，将控制权交给js 解析，直到js 解析完成，再将控制权交给css和dom 资源的解析和构建；
>5. css 解析时候，暂停解析文档，当css 资源解析完后，构建cssom 树，js的执行将延迟,直到css 解析构建完毕。避免js 的执行，影响到cssom 的构建；(css 资源在js 资源之前)
>6. 在cssom 树和dom 树构建完成之后，会按照一定的规则，相互匹配，构建出layoutTree
>7. 最后，计算每个节点的位置，大小相关信息，绘制到页面上；
>8. 在遇到img 标签的时候，会异步加载图片资源，并不会阻塞页面，然后等图片资源加载完毕之后，就会重排/回流页面，展示图片
>
>https://blog.csdn.net/u014240243/article/details/79128292

###### 优化加载js文件

https://blog.csdn.net/liuhe688/article/details/51247484

>***deder***:本质是开启了另一个线程加载脚本。
>
>1、在加载解析dom 结构的同时，也会加载js 文件。拥有defer属性的script 标签，会在dom加载解析完成和js 文件加载完成之后，再运行解析js代码
>
>2、如果有多个defer的脚本执行，会按照顺序执行
>
>3、defer只使用在外联脚本中，内联脚本没有效果
>
>4、`defer`脚本会在`DOMContentLoaded`和`load`事件之前执行
>
>
>
>***async***:`async`和`defer`一样，不会阻塞当前文档的解析，它会异步地下载脚本，但和`defer`不同的是，`async`会在脚本下载完成后立即执行，如果项目中脚本之间存在依赖关系，不推荐使用`async`
>
>1. 只适用于外联脚本，这一点和`defer`一致
>2. 如果有多个声明了`async`的脚本，其下载和执行也是异步的，不能确保彼此的先后顺序
>3. `async`会在`load`事件之前执行，但并不能确保与`DOMContentLoaded`的执行先后顺序

#### 9、防抖和节流（了解实现原理）

>**防抖**(debounce)：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，以新的时间为准，n 秒后在执行，在键盘事件：keyup，keydown ,联想搜索时可以用
>
>**节流**(throttle)：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。页面大小变化，resize,监听滚动事件等
>
>**原因**：1、节约连接访问资源；2、减少浏览器渲染的代价(回流和重绘)

####10、原型、原型链和继承

>原型：每一个函数对象都有个prototype的属性，这个属性指向一个原型对象，这个就称为原型；同样在普通的实例对象中都有一个[__proto__]属性指向对象，这个对象就是原型对象，在原型对象中，有一个constructor属性，指向函数对象，一般是构造函数对象
>
>原型链：A对象实例的proto指向B的实例，此时B的实例中也有proto 指向另一个对象的实例，如此递进，最后会形成由原型构成的链，称为原型链。
>
>继承：
>
>原型继承：原型链上定义的所有属性和方法，都会被实例共享；不能够向父对象传参；
>
>借用构造函数继承：在子类构造函数中使用parent.call(this),就能够继承父类原型上的属性；
>
>​								缺点：1、不能很好地复用，所有的实例属性都在构造函数中定义；
>
>​											2、父类的方法对子类实例来说是不可见的；
>
>组合继承：原型链的继承方式：解决了实例属性继承父类方法的问题；借用构造函数继承，解决每个实例属性都有自己属性的问题(传参)
>
>ES6 的class extends 关键字继承

#### 11、路由模式 history、hash

#### 12、项目性能优化

		###### 要点

>**（1）代码层面的优化**
>
>- v-if 和 v-show 区分使用场景
>- computed 和 watch  区分使用场景
>- v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
>- 长列表性能优化
>- 事件的销毁
>- 图片资源懒加载
>- 路由懒加载
>- 第三方插件的按需引入
>- 优化无限列表性能
>- 服务端渲染 SSR or 预渲染
>
>**（2）Webpack 层面的优化**
>
>- Webpack 对图片进行压缩
>- 减少 ES6 转为 ES5 的冗余代码
>- 提取公共代码
>- 模板预编译
>- 提取组件的 CSS
>- 优化 SourceMap
>- 构建结果输出分析
>- Vue 项目的编译优化
>
>**（3）基础的 Web 技术的优化**
>
>- 开启 gzip 压缩
>- 浏览器缓存
>- CDN 的使用
>- 使用 Chrome Performance 查找性能瓶颈

#### 13、es5 继承中的的this和es6继承中的的this实现有何不同？

> es5的继承中的this，指向的子对象的实例，然后通过父对象调用call将父对象的属性绑定到子对象上；
>
> es6的继承中的this，es6中的继承通过class 和super()关键字来实现，第一步，通过super()，相当于调用父对象的构造函数先实例化一个父对象this,然后在子对象构造函数中将父对象的this修饰指向子对象，此时子对象就能全部继承父对象的属性。这也解释了，为什么通过es6 继承的时候需要在构造函数中调用super

#### 14、作用域 & 作用域链

> 作用域：变量的影响范围，作用域是变量创建的时候就已经确定，并不是执行的时候确定；
>
> 作用域链：变量的查找范围，在创建这个变量的地方，向上查找。

#### 15、[闭包](https://segmentfault.com/a/1190000012646221)

#### 16、箭头函数

> 定义：指向定义时的所在的对象
>
> 1、定义时，箭头函数没有this，本身是继承父级作用域的this；
>
> 2、本身是没有this对象，默认绑定的定义时的this对象；
>
> 3、不能通过call,apply改变绑定的this对象；
>
> 4、一旦绑定，就不能更改；
>
> 5、箭头函数中的this，指向的是函数定义位置（定义作用域）的上下文this；
>
> 6、箭头函数的this是继承父执行上下文里面的this；
>
> 其实5，6两者是一个意思，因为在定义箭头函数作用域时候，会把父级作用域，包括this，继承到箭头函数

#### 17、js 代码运行

> 分为两个阶段，代码编译和代码执行
>
> 代码编译：将代码翻译成可执行的代码，这个时候确定作用域的访问规则；
>
> 代码执行：会生成执行上下文，
>
> 执行上下文分为创建和执行两个生命周期
>
> 创建周期：创建变量对象(函数，var 等)，确定this的指向，确定作用域链；
>
> 执行周期：为变量赋值，函数引用、执行其他代码
>
> 创建函数的时候：就会确定函数的作用域，并将父级的变量对象，保存当执行上下文的内部属性scope中，随后，创建自己当前执行上下文的时候，自身的变量对象放到scope 的前面，在到自己执行上下文的执行周期时，在当前上下文中找不到的变量，就会向后寻找，也就是在保存父级的scope中寻找，就形成了作用域链。
>

###第二部分

1. 实现两列等高

   > __flex 布局__
   >
   > 1、父窗体flex 布局parent:{dispaly:flex;};
   >
   > 2、父窗体display:table,子元素:table-cell ；
   >
   > 3、视觉上的等高：父窗体overflow:hidden,两个子窗体分别设置一个特别大的padding-bottom:999px;然后用margin-bottom:-999px 纠正回来；
   >
   > 缺点：1兼容性不好，2兼容性好，3并不是真正的等高，只是视觉上的；

2. 哪些标签会阻塞页面渲染？怎样解决白屏问题

   > 引用css 的标签 link、style;引用 js 的标签：script
   >
   > 阻塞的原因：由于整个页面渲染是单线程的，在构建dom 树或者cssrom树的时候，只有等构建完毕之后，才能继续后面的渲染，这个时候就是就阻塞了。这个时候不阻塞等他渲染完毕，一边渲染，一边进行另外的操作的话，整个页面就会不稳定；加载js 的标签同样如此，因为js 脚本会执行dom 操作，如果不等他加载解析完毕，也就是阻塞，一边解析，一边进行另外的操作，页面同样也会不稳定。
   >
   > 整个加载外部资源的过程并不会阻塞渲染，因为是异步的，解析执行的时候才会阻塞渲染。
   >
   > __优化阻塞的方式__：1、将script 放在body后；2、为script 标签添加defer 或者async 属性
   >
   > 3、将css 分成很多小块，提高加载速度；
   >
   > __优化白屏__：1、SSR 服务端渲染，将dom 解构和数据在服务端渲染好，直接可以在页面上展示出来，不需要动态加载数据和脚本；
   >
   > 2、骨架屏：用webpack插件(page-skeleton-plugin)实现，实现原理是等页面加载渲染后，保留原来的样式，删减dom 中的元素，然后覆盖需要展示的区域，图片什么的，然后将html 和css 提取出来放到pathname文件夹下就行；
   >
   > 3、预渲染：使用webpack 插件(prerender-spa-plugin),会在编译阶段，将需要预渲染的路由插入到需要展示页面的节点中，可以预先渲染出页面，等js 解析完毕后，就会用真实的节点替换展示的节点；
   >
   > 4、对静态资源的优处理，CDN 网络缓存数据等，优化阻塞的方式等；

3. z-index 定位的问题

   >z-index 同样的层级，后面的dom 会覆盖掉前面的dom;
   >
   >层叠上下文：
   >
   >1、子孙元素的z-index 不会和父元素外的z-index 相比；
   >
   >2、弹窗是否能够不被遮住，完全不取决于自身，而是取决于离他最近的父元素z-index,而此父元素由取决于他的父元素；
   >
   >在设计弹窗的时候，尽量将弹窗元素放到没有设置z-index 的元素下面。就是解决2中的问题
   >
   >https://zhuanlan.zhihu.com/p/28960742

4. 严格模式下未声明的变量会报错，非严格模式不会？

   > 变量分为申明阶段和赋值阶段，在申明阶段，相当于给变量分配了一个空间，赋值的时候，直接把对应的值塞到这个空间里面就行；
   >
   > 而在严格模式下，都没有声明这个变量，相当于没有找到这个空间，必须报错；
   >
   > 在非严格模式下，所有的变量都是window 的属性，所以相当于在window有个这个属性，并且给这属性给了空间，只是没有赋值而已，所以不会报错

5. call,apply,bind 的区别

   >__相同点__:都会改变this 的指向；
   >
   >__不同点__
   >
   >*call*:第二个参数传递每一个单个的数据(this,1,2,3,4,)
   >
   >*apply*:第二个参数传递一个数组(this,[1,2,3,4])
   >
   >*bind*:改变指向后不会马上执行，var newthis= func.bind(this,arg1,arg2...); newThis();这个时候才会执行；

6. 上下两个div 分别设置margin-bottom 和margin-top重叠的问题计算以及原因

   >__计算__：1、全部是正值取最大值；2、不全是正值，则都取绝对值，然后用正值的最大值减去绝对值的最大值；3、没有正值，则都取绝对值，然后用0减去绝对值的最大值。
   >
   >__原因__：[BFC](https://github.com/zuopf769/notebook/blob/master/fe/BFC%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/README.md)
   >
   >```
   >Box垂直方向的距离由margin决定。属于同一个BFC(上例中是body根元素的BFC)的两个相邻Box的margin会发生重叠
   >BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然
   >BFC的区域不会与float box重叠。
   >计算BFC的高度时，浮动元素也参与计算
   >
   >生成BFC
   >float的值不为none:应用在自身
   >overflow的值不为visible:应用在子身或者父元素
   >display的值为inline-block、table-cell、table-caption：子身
   >position的值为absolute或fixed:自身
   >```

7、一个自认为很好的项目，业务组件和代码组件？

8、react 受控组件和非受控组件？

> __受控组件__：1、表单元素展示依赖于状态，使用用户的输入维护自己的状态
>
> 2、继承React.Component 才会有状态
>
> __非受控组件__:1、没有状态，操作非受控组件相当于操作dom
>
> 操作方式:在实例的构造函数中，使用React.creatRef声明一个属性，绑定到组件实例上

9、**react 的diff 算法！！！！！**

10、**react 的执行调用情况，什么候会调用diff 算法**

11、css 水平垂直居中

12、移动端的问题：怎样使不同的设备展示的一样

13、移动端的缩放比例是怎么计算的？

14、rem 和em 的怎么确定的

15、跨域的问题 1、哪些方式可以跨域 2、怎样防止跨域的副作用3、跨域是服务端决定的还是客户端决定的

> 1、跨域是服务端决定的，因为目的是在不同域的服务器获取资源，是由服务器决定的
>
> 跨域带来的副作用：1、CORS 来个预检请求，防止副作用；
>
> 2、服务器可以设置携带身份证cookie等，Access-Control-Allow-Credentials为true
>
> 3、防止CSRF(跨站请求伪造)：在不受同源限制的标签中添加恶意的js 代码，一定的情况下，可以携带cookie 等认证信息进行访问；
>
> __解决方式__:验证HTTP Refer 字段、请求地址添加token 、HTTP头中添加一个定义属性的验证信息、添加随机验证码强迫人机交互。
>
> HTTP Refer:告诉服务器这个在什么位置访问的资源，服务器就可以验证是否来自于限定的网址，一致就放行，不一致就不放行
>
> 下面三种情况会发送
>
> （1）用户点击网页上的链接。
>
> （2）用户发送表单。
>
> （3）网页加载静态资源，比如加载图片、脚本、样式。
>
> Token：在http 请求参数中添加一个随机的参数token ,让服务端进行验证
>
> 自定义认证信息：请求头中添加自定义的信息，可以是token

16、**异步，promise、await/async区别和原理**

> __promise__:
>
> 1、promise 的本质上是一个容器，储存未来某一短时间要发生的事件；
>
> 2、状态不受外界的影响，只有异步操作的结果决定对象的状态
>
> 3、状态一旦固定无法更改
>
> 4、将原来的回调地狱改为链式调用，但是链式调用仍然不够优雅，一眼望去全部是then...
>
> __generator__
>
> 1、generator 函数就是一个封装的异步任务的容器，异步需要暂停的地方，也就是yield ，待运行权返回后在执行,yield 返回的不是一个值，而是一个指针，通过next移动指针，就输出每一个阶段的结果;
>
> 2、不能明确的表示何时向下执行；
>
> __await/async__:
>
> 1、本质是一个generator 的语法糖，并且内置执行器，没有必要使用next一行一行的向下执行；
>
> 2、语义性更好：async 表示有异步操作，await 表示需要等待结果；
>
> 3、async 的函数调用，会返回一个promise 对象，意味着可以使用then 执行下一步操作，或者使用catch 捕获错误；
>
> 4、遇到await 先返回，等到异步操作完成，在执行后面的操作语句；
>
> 5、await 后面的操作如果不存在依赖的关系，同时触发；

串行执行promise

> ```
> Array.prototype.reduce`、使用`async + 循环 + await`、 或者使用新出的`for await of
> ```

17、版本发布的流程

18、**浏览器加载资源的流程，遇到img、多媒体标签怎么办？**

> 遇到图片的时候回发起请求图片，但是不会影响渲染的，等图片加载完毕之后，影响了页面布局，触发回流，重新页面；

19、react中key 的作用

> 1、重用或者定位

20、http 和https 的区别

21、eventloop 的执行问题，一个eventloop 的时间

23、react 为什么会有 componentWillReceiveProp这个生命周期

24、commonjs 和es6的模块机制有什么区别？

> __Commonjs__
>
> 1、对于数据是浅复制，在一个模块中对基本的数据类型的更改，不会影响到其他的模块，但是对于引用类型的数据，修改会影响到其他模块的数据；
>
> 2、模块只会加载一次，就会缓存，第二次加载的时候直接取缓存就行，并不会动态变化，可以清除缓存；
>
> 3、模块之间循环引用，加载多少就输出多少，并且是在require的时候就全部输出，加载时执行；
>
> __ES6__
>
> 1、模块中的应用是`动态只读引用`，不能修改模块中的内容，并且只是加载了模块的引用，等到执行的时候，采取加载其中的值(import的时候，只是加载了一个引用)
>
> 2、动态：就是模块本身变化了之后，import 进来的值也会发生变化；
>
> 3、循环引用的时候，只要存在引用就能执行

25、变量提升

> 现像：var,function 变量在还未申明的时候，就可以使用；
>
> 原因:js 在编译的时候，会将function 和var 申明的移动到作用域的顶部；
>
> 实际原因：在变量对象的创建过程中，检查上下文中的变量
>
> 1、检查function 申明的变量，在变量对象中以函数名为属性，创建一个属性，如果遇申明相同的属性名，后面覆盖前面的；
>
> 2、检查var 申明的变量，每一个都在变量对象中申明一个对应的属性，并赋给初始值 undefined，同样后面有相同的会后者覆盖前面的 ；
>
> 由此知道，一个变量的生命周期有三个
>
> __(创建、初始化)—赋值—回收__
>
> var 声明的变量，只是在创建的时候，马上就初始化了，所以在访问的时候并不会报错，也就是说，将创建和初始化提升了
>
> let申明的变量，存在暂死性区域，在声明之前访问，会报错(创建提升了，初始化没有提升)
>
> 暂死性区域：在创建之后，未进行词法绑定(初始化)的这段时间，不能使用变量
>
> 1. let 的「创建」过程被提升了，但是初始化没有提升。
> 2. var 的「创建」和「初始化」都被提升了。
> 3. function 的「创建」「初始化」和「赋值」都被提升了

26、for 循环中的let 和var

```js
for(var i=0;i<2;i++){ a[i] = function(){console.log(i)}}
相当于在父作用域中声明了一个变量var i =0;然后每次在子作用域进行
var i= 0;
if(i<10){
	 a[i] = function(){console.log(i)}
}
i++;
a[1]=2;
a[2]=2;
这样循环遍历完成后，只在全局作用域中找到最后的i的值，就是10；
但是在for(let i=0;i<10;i++){a[i] = function(){console.log(i)};}
相当于每次使用let 声明了一个块级作用域，并给每次let初始化了一个新的i值，由于每次都是块级作用域，所以每次声明都不互相影响，并且根据js 的机制，会记住上次循环中的值，作为下次循环的初始值，所以会访问到上一次块级作用域的i值；
let i= 0;
if(i<10){
  let k = i;
	 a[k] = function(){console.log(k)}
}
i++;
相当于产生了一个中间量来保存，上一次循环的值，同时产生了一个块级作用域，赋值操作访问到外层的i值；

另一种解释：
let：ES6中，每次进入循环内，相当于进入一个新的作用域。此时，当定义一个函数时，函数会拷贝父作用域到[[scopes]]属性上。此时的i（基本数据类型）的值直接被拷贝进来。所以进入3次时这个i被拷贝了3次。当执行a的函数时，会将每个函数的[[scopes]]属性放到当前执行环境的作用域链上，所以输出的是不同的i值。

var：在循环条件里定义时这个i是被添加到全局变量里，每次执行循环条件都是修改的全局变量，定义函数时拷贝的是全局变量（含i），此时的父级作用域并没有i，所以最终的访问结果都是3。

上面说的拷贝都是值拷贝，如果这个变量是基本数据类型，则具体的值会被拷贝进行，如果这个变量是引用类型，则拷贝的是其地址。所以使用以下例子：
var a = []
for (let y = {i:0}; y.i<3; y.i++) {
a[y.i] = function(){
console.log(y.i)
}
}
a[0]()
a[1]()
a[2]()
就会发现，每次的输出结果都是3。因为y这个对象被拷贝了，每次修改的i都是其内部的值。

https://www.cnblogs.com/echolun/p/10584703.html
```

27、实现同心圆

> 1、两个div：嵌套，父元素 overflow:hidden;设置overflow:hidden 产生bfc;
>
> 2、一个div: box-shadow: 0 0 0 30px rgba(0,0,0);// 分别对应 x,y,模糊半径，扩散半径，颜色；外圆大小由同心圆决定；
>
> 3、伪元素

```html
// 两个div
<div class='p'>
	<div class='c'>
  </div>
</div>

<style>
  .p{
    width:100px;
    height:100px;
    background:red;
    border-radius:50%;
    overflow:hidden;
  }
  .c{
    width:50px;
    height:50px;
    background:black;
    border-radius:50%;
    margin:25px auto;
  }
</style>

一个元素
<div id="d3"></div>
// box-shadow
<style> 
#d3{
    background-color: #ff5000;
    width: 150px;
    height: 150px;
    margin: 30px;
   border-radius: 50%;
   position: relative;
   box-shadow: 0 0 0 30px rgba(255,80,0,.2);
}

// 伪元素的方式
#d3::before {
    content: '';
    width: 80px;
    height: 80px;
    background-color: green;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%,-50%);
   	border-radius: 50%;
}

</style>
```

 ### 第三部分

### JS 基本数据

1. ++i和i++的区别

   >i++ 返回原值,但是i会变成增加之后的值

   ```js
   var i=0;
   var j = i++;
   // j输出0，i;
   ```

   > ++i 返回增加之后的值，i 也会变成增加之后的值

2. 函数传递参数

   >__传递方式__:按值传递
   >
   >传递的是值类型参数时，相当于在函数内部声明了一个局部变量，函数内部局部变量的改变不会影响外部变量

   ```js
   var num = 1;
   function add(num){
     num = num+1;
     console.log(num) // 2
   }
   console.log(num) //1
   // num 内部改变不会影响外部
   ```

3. js事件

   > 事件模式：冒泡事件和捕获事件
   >
   > 冒泡事件：从绑定事件的dom逐渐向外，直到最顶层dom，阻止冒泡 e.stopPropagation()或者e.cancelBubbe();
   >
   > 捕获事件：从顶层的dom逐渐穿透到最底层，到达绑定事件的dom
   >
   > 阻止默认事件：e.preventDefault();
   >
   > 添加事件监听 addEventListener("click",callback,false)
   >
   > 第一个参数:绑定事件的类型
   >
   > 第二个参数:回调函数
   >
   > 第三个参数：默认为false，是执行冒泡事件，true 执行捕获事件

4. 哪些数组的操作方法属于es5，哪些属于es6

   > Es6：find、findIndex、includes、copyWithin、Array.form(将类数组对象转换为数组)
   >
   > Es5：forEach、map、filter、reduce、indexOf
   >
   > Es3js:push、slice、splice、shift、unshift、pop、concat
   >
   > 不会影响原数组的方法
   >
   > Map、concat、slice

5. for...of 、for...in 和Object.keys()的区别

   > for...of：一般在遍历数组的时候使用，循环出的是数组的值；支持遍历数组，类数组对象（DOM NodeList），字符串，Map 对象，Set 对象；
   >
   > for...in:一般在遍历对象的时候使用，遍历对象及其原型链上可枚举的属性；
   >
   > Object.keys:遍历对象自身的可枚举属性，不包括原型链上的属性

6. document.write 和 document.open 

   > document.write：向一个文档流中写入内容
   >
   > document.open ：打开一个全新的文档流，内容全空
   >
   > setTimeout(function(){
   >
   > ​        document.write("2222");
   >
   > ​    },1000);`
   >
   > 表示等全部的文档流加载完毕后，1庙后，重新 document.open 一个全新的文档，内容为空，然后写入写入222的字符串，覆盖掉原来的内容；

7. js 运算符

   >比较运算符：== 会转换成 number 进行比较
   >
   >逻辑运算符：会转换成boolean 进行比较
   >
   >Null，undefined ,空字符串，NaN、0，-0转换成boolean值为false ,其他都为true;
   >
   >逻辑运算符优先级高于比价运算符
   >
   >[] == ![]
   >
   >右边：
   >
   >1、数组转换为boolean 值为true，！取反为false；
   >
   >2、false转换为number为0；
   >
   >左边：
   >
   >1、没有逻辑运算符，进行隐式转换
   >
   >2、空数组转换成基本的数据类型，先通过valueOf，没有得到基本的数据类型，也就是原始值，在进行toString转换；

8. 变量回收

   > 1、全局变量不会回收
   >
   > 2、局部变量使用完会被回收
   >
   > 3、使用中的变量不会被回收

9. querySelectorAll("#id"):传入一个css 

10. js 触摸事件有哪些？

11. bit 是位，byte 是字节，8bit  = 1byte;js 中的数字全部是用64位存储

12. js 对数组空位的处理

    > ES5
    >
    > forEach(), filter(), reduce(), every() 和some()都会跳过空位。
    >
    > map()会跳过空位，但会保留这个值
    >
    > join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。
    >
    > ES6 中都会将空位当做undefined

13. 作用域

14. 正则表达式

不会改变数组的数组方法        

> concat、slice、map、filter、some、every
>
> for 循环对原来的数组操作，会改变原数组
>
> foreact   	
>
> 

16、字符串连接机制

>a+=b;
>
>新建一个临时字符串，将新字符串赋值为a+b，然后返回这个临新字符串并同时销毁原始字符串，所以字符串连接效率较低。所以用Array.join()不会新建临时字符串效率更高
>
>__连接过程中的隐式转换__
>
>①为任意的数据类型+""即可将其**转换成String**字符串类型，这是一种隐式类型转换，由浏览器自动完成，实际上也是调用String()函数。
>
>②为任意的数据类型 -0 即可将其**转换成Number**数值类型。
>
>var foo = "10"+3-"1"; // 输出102

17、new的执行过程

> 1、新建一个空对象
>
> 2、将空对象的[[proto]]指向这个构造函数的prototype，可以实现继承
>
> 3、将空对象赋值给this

### 不清楚名词

> ### clientHeight、scrollTop 和 offsetTop



